import numpy as np
import covidfuncs.datfuncs as cvdf
import covidfuncs.dffuncs as cvdff
from scipy.integrate import odeint


def get_tdouble(covid_df, col, mincol=100, maxcol=20000):
    """
    Get the doubling time.
    """

    log_fit = cvdff.get_log_fit(covid_df, col, mincol, maxcol)

    f1 = log_fit[1]

    tdouble = np.log(2) / (f1 * np.log(10))

    return tdouble


def get_r0(covid_df, col, gamma=1.0 / 16.6, mincol=100, maxcol=20000):
    """
    Get the R0 from the SIR model.
    """

    tdouble = get_tdouble(covid_df, col, mincol=100, maxcol=20000)

    r0 = 1 + np.log(2) / (gamma * tdouble)

    return r0


def get_sirmodel(covid_df,
                 col,
                 N=80 * 10**6,
                 I0=100,
                 Rec0=0,
                 beta=0.31,
                 gamma=1 / 16.6,
                 tdays=60):
    """
    Compute SIR model
    """

    # # Total population, N.
    # N = 80*10**6
    # # Initial number of infected and recovered individuals, I0 and Rec0.
    # I0, Rec0 = 100, 0
    # Everyone else, S0, is susceptible to infection initially.
    S0 = N - I0 - Rec0

    # # Contact rate, beta, and mean recovery rate, gamma, (in 1/days).
    # beta, gamma = 0.31, 1./16.6
    # r0 = beta/gamma
    # A grid of time points (in days)
    t = np.linspace(0, tdays, 10 * tdays)

    # The SIR model differential equations.
    def deriv(y, t, N, beta, gamma):
        S, I, R = y
        dSdt = -beta * S * I / N
        dIdt = beta * S * I / N - gamma * I
        dRdt = gamma * I
        return dSdt, dIdt, dRdt

    # Initial conditions vector
    y0 = S0, I0, Rec0
    # Integrate the SIR equations over the time grid, t.
    ret = odeint(deriv, y0, t, args=(N, beta, gamma))
    S, I, R = ret.T

    return S, I, R, t
